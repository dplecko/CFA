% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fair-decisions.R
\name{fair_decisions}
\alias{fair_decisions}
\title{fair_decisions}
\usage{
fair_decisions(
  data,
  X,
  Z,
  W,
  Y,
  D,
  x0,
  x1,
  xgb_params = list(eta = 0.1),
  xgb_nrounds = 100,
  po_transform = function(x) x,
  po_diff_sign = 0,
  method = c("debiasing", "causal_forest", "medDML"),
  model = c("ranger", "linear"),
  tune_params = FALSE,
  nboot1 = 1L,
  nboot2 = 100L,
  ...
)
}
\arguments{
\item{data}{Object of class \code{data.frame} containing the dataset.}

\item{X}{A \code{character} scalar giving the name of the
protected attribute. Must be one of the entries of \code{names(data)}.}

\item{Z}{A \code{character} vector giving the names of all mediators.}

\item{W}{A \code{character} vector giving the names of all confounders.}

\item{Y}{A \code{character} scalar giving the name of the outcome.}

\item{D}{\code{character(1L)} with the name of the decision/control variable.}

\item{x0, x1}{Scalar values giving the two levels of the binary protected
attribute.}

\item{xgb_params}{\code{xgboost} parameters passed to the fit.}

\item{xgb_nrounds}{Number of boosting rounds in \code{xgboost}.}

\item{po_transform}{An arbitrary transformation function that can be
applied to the potential outcomes \eqn{Y_{d}} when computing the benefit
\eqn{\Delta}, meaning that \eqn{E[f(Y_{d_1}) - f(Y_{d_0}) \mid x, z, w]} is
used for \eqn{\Delta}.}

\item{po_diff_sign}{The difference of potential outcomes
\eqn{Y_{d_1} - Y_{d_0}} sometimes may have a specific sign (-1 or 1). When
this argument is specified, the sign is enforced.
Default value is 0, which (in principle) allows for both
positive and negative differences (i.e., there is no monotonicity).}

\item{method}{A \code{character} scalar with three options:
\code{"debiasing"} for a one-step debiasing approach with underlying
\code{xgboost} learners, \code{"causal_forest"} for the
\code{\link[grf:causal_forest]{grf::causal_forest()}} method from the \code{grf} package, and
\code{"medDML"} for mediation double-machine learning.}

\item{model}{A \code{character} scalar taking values in
\code{c("ranger", "linear")}, indicating whether a tree-based learner is used
\code{\link[ranger:ranger]{ranger::ranger()}}, or if the fitted model should be linear. This parameter
is only relevant if \code{method == "medDML"}.}

\item{tune_params}{A \code{logical(1L)} indicating whether the parameters
should be tuned for the tree-based methods (only the \code{min.node.size}
parameter is tuned). Defaults to \code{FALSE}.}

\item{nboot1}{An \code{integer} scalar determining the number of outer
bootstrap repetitions, that is, how many times the fitting procedure is
repeated. Default is \code{1L}. This parameter is ignored if
\code{method == "debiasing"}.}

\item{nboot2}{An \code{integer} scalar determining the number of inner
bootstrap repetitions, that is, how many bootstrap samples are taken after
the potential outcomes are obtained from the estimation procedure.
Default is \code{100L}. This parameter is ignored if
\code{method == "debiasing"}.}

\item{...}{Further arguments passed to downstream model fitting functions.}
}
\value{
An object of class \code{fair_decision} with elements:
\item{\code{d_fcb}, \code{delta_fcb}}{Fairness Cookbook objects for the
decision \eqn{D} and the benefit \eqn{\Delta}.}
\item{\code{delta}}{Estimated values of the benefit \eqn{\Delta}.}
\item{\code{data}, \code{po_diff_sign}, \code{po_transform},
\code{xgb_params}}{See input definitions.}
\item{\code{xgb_mod}}{\code{xgboost} model for estimating the benefit
\eqn{\Delta}.}
\item{\code{X, Z, W, Y, D}}{Names of protected attribute, confounders,
mediators, outcome, and the decision/control variable.}
\item{\code{x0, x1}}{Levels of protected attribute.}
\item{\code{method}}{Estimation method. See \verb{@param method}.}
\item{\code{model}}{Model class for \code{method == "medDML"}.}
\item{cl}{Generating function call.}
\item{params}{If \code{tune_params == TRUE} in the function call, this object
is a list of optimal \code{min.node.size} values for each tree-based used
in the estimation procedure. See \code{faircause:::doubly_robust_med()} and
\code{faircause::crf_wrap()} for more details about the used objects.}
}
\description{
Implementation of the Outcome Control algorithm described in Causal Fairness
Analysis (Plecko & Bareinboim 2024). Uses only plain \code{R}.
}
\details{
The procedure takes the data as an input, together with
the causal graph given by the Standard Fairness Model, and a choice of a
specific control/decision variable (input \code{D}). It outputs an S3 class object
of type \code{fair_decision} which contains the estimates of the conditional
average treatment effects (CATEs) of variable \eqn{D} on \eqn{Y}, conditional
on the values of \eqn{X, Z, W}. This quantity is also referred to as the
benefit, and is defined as:
\deqn{\Delta := E[Y_{d_1} - Y_{d_0} \mid x, z, w].}
Subsequently, several steps of Outcome Control are performed. First, the
causal decomposition of the original decision \eqn{D} is performed. Secondly,
the decomposition of the benefit \eqn{\Delta} is performed. Finally, the
benefit fairness criterion is investigated. All of these can be inspected by
applying the \code{autoplot()} function on the S3 object. Also, the object allows
for predictions of the benefit values, and of construct decisions, using the
\code{predict()} function.
}
\references{
Plecko, D. & Bareinboim, E. (2022).
Causal Fairness Analysis \cr
}
\author{
Drago Plecko
}
